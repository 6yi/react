webpackJsonp([0xe5dd7aa1403c],{934:function(n,t){n.exports={data:{markdownRemark:{html:'<h2 id="严格模式"><a href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>严格模式</h2>\n<p><code class="gatsby-code-text">StrictMode</code>是一个用以标记出应用中潜在问题的工具。就像<code class="gatsby-code-text">Fragment</code>，<code class="gatsby-code-text">StrictMode</code>不会渲染任何真实的UI。它为其后代元素触发额外的检查和警告。</p>\n<blockquote>\n<p>注意:\n严格模式检查只在开发模式下运行，不会与生产模式冲突。</p>\n</blockquote>\n<p>你可以在应用的任何地方启用严格模式。例如：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">\'react\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">ExampleApplication</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Header</span> <span class="token punctuation">/></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>React.StrictMode</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ComponentOne</span> <span class="token punctuation">/></span></span>\n          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ComponentTwo</span> <span class="token punctuation">/></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>React.StrictMode</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Footer</span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>在上面的例子中，不会对组件<code class="gatsby-code-text">Header</code>、<code class="gatsby-code-text">Footer</code>进行strict mode检查。然而<code class="gatsby-code-text">ComponentOne</code>、<code class="gatsby-code-text">ComponentTwo</code>以及它们所有的后代将被检查。</p>\n<p><code class="gatsby-code-text">StrictMode</code>目前有助于：</p>\n<ul>\n<li><a href="#%E8%AF%86%E5%88%AB%E5%85%B7%E6%9C%89%E4%B8%8D%E5%AE%89%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%BB%84%E4%BB%B6">识别具有不安全生命周期的组件</a></li>\n<li><a href="#%E6%9C%89%E5%85%B3%E6%97%A7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2ref%E7%94%A8%E6%B3%95%E7%9A%84%E8%AD%A6%E5%91%8A">有关旧式字符串ref用法的警告</a></li>\n<li><a href="#%E6%A3%80%E6%B5%8B%E6%84%8F%E5%A4%96%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8">检测意外的副作用</a></li>\n</ul>\n<h3 id="识别具有不安全生命周期的组件"><a href="#%E8%AF%86%E5%88%AB%E5%85%B7%E6%9C%89%E4%B8%8D%E5%AE%89%E5%85%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>识别具有不安全生命周期的组件</h3>\n<p>如同在<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html">博客</a>中阐明的，在异步React应用中使用某些老式的生命周期方法不安全。但是, 如果应用程序使用第三方库, 则很难确保不使用这些生命周期方法。幸运的是, 严格的模式可以帮助解决这个问题!</p>\n<p>当启用严格模式, React将编译一个所有使用不安全生命周期组件的列表，并打印一条关于这些组件的警告信息，就像：</p>\n<p><img src="https://reactjs.org/static/strict-mode-unsafe-lifecycles-warning-e4fdbff774b356881123e69ad88eda88-2535d.png"></p>\n<h3 id="有关旧式字符串ref用法的警告"><a href="#%E6%9C%89%E5%85%B3%E6%97%A7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2ref%E7%94%A8%E6%B3%95%E7%9A%84%E8%AD%A6%E5%91%8A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有关旧式字符串ref用法的警告</h3>\n<p>以前，React提供了2种方法管理ref：旧式的字符串ref API和回调API。虽然字符串ref API更加方便，但它有些许<a href="https://github.com/facebook/react/issues/1373">缺点</a>，因此我们的正式建议是<a href="https://doc.react-china.org/docs/refs-and-the-dom.html#%E6%97%A7%E7%89%88-api%EF%BC%9Astring-%E7%B1%BB%E5%9E%8B%E7%9A%84-refs">改用回调方式</a></p>\n<p>React 16.3新增了第三种方式, 它提供了字符串 ref 的方便性, 而没有任何缺点:</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-js"><code class="gatsby-code-js">class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.inputRef = React.createRef();\n  }\n\n  render() {\n    return &lt;input type=&quot;text&quot; ref={this.inputRef} /&gt;;\n  }\n\n  componentDidMount() {\n    this.inputRef.current.focus();\n  }\n}</code></pre>\n      </div>\n<p>由于新增的对象式refs很大程度上作为字符串ref的替换，因此strict mode现在对字符串ref的用法发出警告。</p>\n<blockquote>\n<p>注意：\n除了新的createRef API，回调ref将被继续支持。您不需要在组件中替换回调ref。它们稍微灵活一些, 因此它们将保持为高级功能。</p>\n</blockquote>\n<p><a href="https://doc.react-china.org/docs/refs-and-the-dom.html">学习更多有关createRef API内容</a></p>\n<h3 id="检测意外的副作用"><a href="#%E6%A3%80%E6%B5%8B%E6%84%8F%E5%A4%96%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>检测意外的副作用</h3>\n<p>理论上，React在两个阶段起作用:</p>\n<ul>\n<li><strong>渲染</strong>阶段决定了需要对 DOM 进行哪些更改。在此阶段, React调用<code class="gatsby-code-text">render</code>(方法), 然后将结果与上一次渲染进行比较。</li>\n<li><strong>提交</strong>阶段是React执行任何更改的阶段。(在React DOM中, 指React插入、更新和删除 dom 节点）。在此阶段React也调用生命周期, 如 <code class="gatsby-code-text">componentDidMount</code> 和 <code class="gatsby-code-text">componentDidUpdate</code> 。</li>\n</ul>\n<p>提交阶段通常很快，但是渲染可能很慢。因此, 即将出现的异步模式 (默认情况下尚未启用) 将呈现工作分解为片断, 暂停和恢复工作以避免阻止浏览器。这意味着在提交之前, 反应可能不止一次地调用渲染阶段生命周期, 或者它可以在不提交的情况下调用它们 (因为错误或更高的优先级中断)。</p>\n<p>渲染阶段的生命周期包括以下class component方法：</p>\n<ul>\n<li><code class="gatsby-code-text">constructor</code></li>\n<li><code class="gatsby-code-text">componentWillMount</code></li>\n<li><code class="gatsby-code-text">componentWillReceiveProps</code></li>\n<li><code class="gatsby-code-text">componentWillUpdate</code></li>\n<li><code class="gatsby-code-text">getDerivedStateFromProps</code></li>\n<li><code class="gatsby-code-text">shouldComponentUpdate</code></li>\n<li><code class="gatsby-code-text">render</code></li>\n<li><code class="gatsby-code-text">setState</code> 更新函数 (第一个形参）</li>\n</ul>\n<p>因为以上方法可能不止一次被调用，所以它们中不包含副作用尤为重要。忽略此规则可能会导致各种问题, 包括内存泄漏和无效的应用程序状态。不幸的是, 很难发现这些问题, 因为它们通常都是<a href="https://en.wikipedia.org/wiki/Deterministic_algorithm">不确定的</a>。</p>\n<p>严格模式不能自动检测到你的副作用, 但它可以帮助你发现它们, 使其更具确定性。这是通过有意地双调用以下方法来完成的:</p>\n<ul>\n<li>Class component <code class="gatsby-code-text">constructor</code></li>\n<li><code class="gatsby-code-text">render</code></li>\n<li><code class="gatsby-code-text">setState</code> 更新函数 (第一个形参）</li>\n<li>static <code class="gatsby-code-text">getDerivedStateFromProps</code></li>\n</ul>\n<blockquote>\n<p>注意：\n只在开发模式生效。生产模式下生命周期不会被双调用。</p>\n</blockquote>\n<p>举个例子，考虑以下代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-js"><code class="gatsby-code-js">class TopLevelRoute extends React.Component {\n  constructor(props) {\n    super(props);\n\n    SharedApplicationState.recordEvent(&#39;ExampleComponent&#39;);\n  }\n}</code></pre>\n      </div>\n<p>乍一看, 这段代码似乎没有问题。但是如果 <code class="gatsby-code-text">SharedApplicationState.recordEvent</code> 不是<a href="https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning">幂等</a>, 那么多次实例化此组件可能会导致无效的应用程序状态。这种微妙的 bug 可能不会在开发过程中显现出来, 或者它可能会不一致, 因此被忽略。</p>\n<p>通过有意的双调用方法 (如组件构造函数), 严格模式使得这样的行为更容易被发现。</p>',frontmatter:{title:"Strict Mode",next:null,prev:null},fields:{path:"docs/strict-mode.md",slug:"docs/strict-mode.html"}}},pathContext:{slug:"docs/strict-mode.html"}}}});
//# sourceMappingURL=path---docs-strict-mode-html-172ec9c7ab69c07b6474.js.map